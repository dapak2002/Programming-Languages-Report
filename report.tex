\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[linguistics]{forest}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Darren Pak  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This is a culmination of all assignments and reports for CPSC-354 taught by Alex Kurz at Chapman University Fall 2022. 
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

My name is Darren Pak and I am a computer science major at Chapman University with a minor in Data Analytics. My current goals as of Fall 2022 are to find interesting job opportunities and career paths that I find enjoyable and are able to sustain my lifestyle. 

\section{Homework}\label{homework}

This section contains solutions to homework assignments. 

\subsection{Week 1}

In Week 1, I will go over Euclid's Algorithm for Greatest Common Divisor and how it is implemented in C++.

\subsubsection{Euclid's Algorithm}

Euclid's Algorithm is defined as follows:

\medskip\noindent 
gcd(a,b):

\medskip\noindent 
Input: Two whole numbers (integers) called a and b, both greater than 0.

\medskip\noindent 
(1) if $$a > b$$ then replace a by a-b and go to (1).

\medskip\noindent 
(2) if $$b > a$$ then replace b by b-a and go to (1).

\medskip\noindent 
Output: a

\medskip\noindent
As described in \href{https://hackmd.io/@alexhkurz/SkqMtH0sK}{Alex Kurz Homework (Week 1)}

\subsubsection{Implementation in C++}

Below is the example for implementation of Euclid's Algorithm in C++:
\begin{lstlisting}
#include <iostream>

using namespace std;

int gcd(int a, int b) {
    while ((a != 1) && (b != 1)) {
        if (a > b) {
            a = a-b;
        }
        if (b > a) {
            b = b-a;
        }
        if (a == b) {
            return a;
        }
    }
    return a;
}

int main()
{
    cout<<gcd(9,33)<<endl;

    return 0;
}
\end{lstlisting}
In the function gcd, there is a while loop checking if either of the inputs are 1. This will eliminate cases where the GCD is already the lowest possible and as described in Euclid's algorithm, will return 1. Within the while loop, we go over the two rules in Euclid's Algorithm. The first being if a is greater than b then a is assigned to a - b. The second rule being if b is greater than a then b is assigned to b - a. Next we resolve the output and return a as the result.
\subsection{Week 2}
Week 2 is focused on recursion and functions in Haskell. For this assignment, I created 6 different functions using recursion in Haskell. Find the full \href{https://github.com/dapak2002/Pak-D-CPSC-354-Report/blob/main/src/hw2.hs}{Github Repository} here.

\subsubsection{Function Select Evens}
Here is a code snippet from the above mentioned Github Repository of the Select Evens function.
\begin{lstlisting}
select_evens :: [a] -> [a]
select_evens [] = []
select_evens (x:xs)
    |mod (length xs) 2 == 1 = x : select_evens xs
    |otherwise = select_evens xs
\end{lstlisting}
This function takes a list as an input and returns a list of only the even index elements. For example, from a list of ["a","b","c","d"] the function would return ["b","d"]. The first line of this function determines the input and outputs which are both lists of elements. The second line determines that an empty list from the function returns an empty list. This will become our indicator for ending recursion. Next we have an if statement saying that after the head, if there are an odd number of elements remaining, then the head element is of an even index. This means it would be appended to the returning list. If there is an even number of elements remaining, this means that the head element is of an odd index, meaning that the head element is skipped and will not be appended to the list. After all of the calculations have completed, the elements are appended to an empty list and added to the front in the order they were calculated.

Collaborated with Adrian Edralin for Week 2 Assignment.

\subsection{Week 3}
Week 3 assignment is focused around the Towers of Hanoi solving algorithm and how to evaluate functions. This game functions with n number of rings and 3 poles where the objective is to move all of the rings from the first pole (0) to the last pole (2). However, you are not able to stack larger rings on top of smaller rings while only moving 1 ring at a time. This game can be played at \href{https://www.mathsisfun.com/games/towerofhanoi.html}{mathisfun.com} in a simulated environment with different numbers rings.

\subsubsection{Rules of the Algorithm}
Our algorithm follows the following rules to solve this puzzle as described in \href{https://hackmd.io/@alexhkurz/rJQwvpyMY}{Towers of Hanoi (Week 3)}:
\begin{lstlisting}
hanoi 1 x y = move x y

hanoi (n+1) x y = 
	hanoi n x (other x y) 
	move x y 
	hanoi n (other x y) y
\end{lstlisting}

When expanded for n = 5 (5 rings), this becomes:
\begin{lstlisting}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{lstlisting}
 This eventually gets simplified to the following moves where $$x->y$$ defines x being a ring moving from tower x to tower y:
 \begin{lstlisting}
 0->2
0->1
2->1
0->2
1->0
1->2
0->2
0->1
2->1
2->0
1->0
2->1
0->2
0->1
2->1
0->2
1->0
1->2
0->2
1->0
2->1
2->0
1->0
1->2
0->2
0->1
2->1
0->2
1->0
1->2
0->2
 \end{lstlisting}

\subsubsection{Analysis Questions}
In our original algorithm, it is shown that "hanoi" shows up 31 times. This is as the number of moves it takes to solve the puzzle meaning that the "hanoi" shows up the same number of times as the number of moves. 

\noindent For 1 ring, this is simple and would only take 1 move to solve. For 2 rings, this is 3 moves to solve. For 3 rings it is 7 moves to solve, for 4 rings it is 15 moves, and for 5 rings it is 31 moves. In this we see a pattern where for each additional ring, you double the amount of moves and add 1. In conclusion if n is the number of rings, this leads us to the equation of moves(n) = 2 * moves(n - 1) + 1, where moves(1) = 1 and n is greater than 0.

\subsection{Week 4}
This week is focused on concrete and abstract syntax trees which are essentially ways to parse equations. 
\subsubsection{Concrete Syntax Trees}

For the concrete syntax trees, we follow the rules and instructions as listed in the \href{https://hackmd.io/@alexhkurz/BkSgRX1GF}{Week 4 Report Instructions}. The rules are listed as following:
\begin{lstlisting}
Exp -> Exp '+' Exp1 
Exp1 -> Exp1 '*' Exp2              
Exp2 -> Integer            
Exp2 -> '(' Exp ')'  
Exp -> Exp1             
Exp1 -> Exp2 
\end{lstlisting}

\noindent 2+1:
\begin{forest}
  for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Exp
    [Exp
        [Exp1
            [Exp2
                [2]
            ]
        ]
    ]
    [+]
    [Exp1
        [Exp2
            [1]
        ]
    ]
  ]
\end{forest}

\noindent 1+2*3:
\begin{forest}
  for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Exp
    [Exp
        [Exp1
            [Exp2
                [1]
            ]
        ]
    ]
    [+]
    [Exp1
        [Exp1
            [Exp2
                [2]
            ]
        ]
        [*]
        [Exp2
            [3]
        ]
    ]
]
\end{forest}

\noindent 1+(2*3):
\begin{forest}
  for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
[Exp
    [Exp
        [Exp1
            [1]
        ]
    ]
    [+]
    [Exp1
        [Exp2
        [(]
            [Exp
                [Exp1
                        [Exp1
                            [Exp2
                            [2]
                            ]
                        ]
                        [*]
                        [Exp2
                            [3]
                        ]
                ]
            ]
        [)]
        ]
    ]
]
\end{forest}

\noindent (1+2)*3:

\begin{forest}
for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Exp1
    [Exp1
        [Exp2
            [(]
            [Exp
                [Exp
                    [Exp1
                        [Exp2
                            [1]
                        ]
                    ]
                ]
                [+]
                [Exp1
                    [Exp2
                        [2]
                    ]
                ]
            ]
            [)]
        ]
    ]
    [*]
    [Exp2
        [3]
    ]
]
\end{forest}

\noindent 1+2*3+4*5+6:
\begin{forest}
    for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
[Exp
    [Exp
        [Exp
            [Exp
                [Exp1
                    [Exp2
                        [1]
                    ]
                ]
            ]
            [+]
            [Exp1
                [Exp1
                    [Exp2
                        [2]
                    ]
                ]
                [*]
                [Exp2
                    [3]
                ]
            ]
        ]
        [+]
        [Exp1
            [Exp1
                [Exp2
                    [4]
                ]
            ]
            [*]
            [Exp2
                [5]
            ]
        ]
    ]
    [+]
    [Exp1
        [Exp2
            [6]
        ]
    ]
]
\end{forest}

\subsubsection{Abstract Syntax Trees}
For the abstract syntax trees, we can find a similar instructions here at \href{https://hackmd.io/@alexhkurz/BkqOWbgMF}{Week 4 Report for Abstract Syntax Trees}. The rules again are listed as following:
\begin{lstlisting}
Plus.   Exp ::= Exp "+" Exp1 ;
Times.  Exp1 ::= Exp1 "*" Exp2 ;
Num.    Exp2 ::= Integer ;

coercions Exp 2 ;
\end{lstlisting}
2+1:
\begin{forest}
    for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Plus
    [Num
        [2]
    ]
    [Num
        [1]
    ]
]
\end{forest}

\noindent 1+2*3:
\begin{forest}
    for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Plus
    [Num
        [1]
    ]
    [Times
        [Num
            [2]
        ]
        [Num
            [3]
        ]
    ]
]
\end{forest}

\noindent 1+(2*3):
\begin{forest}
    for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
  [Plus
    [Num
        [1]
    ]
    [Times
        [Num
            [2]
        ]
        [Num
            [3]
        ]
    ]
]
\end{forest}

\noindent (1+2)*3
\begin{forest}
for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
[Times
    [Plus
        [Num
            [1]
        ]
        [Num
            [2]
        ]
    ]
    [Num
        [3]
    ]
]
\end{forest}

\noindent 1+2*3+4*5+6:
\begin{forest}
for tree={
    parent anchor=south,
    child anchor=north,
    fit=band,
  }
[Plus
    [Plus
        [Plus
            [Num
                [1]
            ]
            [Times
                [Num
                    [2]
                ]
                [Num
                    [3]
                ]
            ]
        ]
        [Times
            [Num
                [4]
            ]
            [Num
                [5]
            ]
        ]
    ]
    [Num
        [6]
    ]
]
\end{forest}

\noindent In regards to the abstract syntax tree of 1+2+3, this would be identical to (1+2)+3 because we read operations from left to right which matches this order of parentheses.

\subsection{Week 5}
Here are the evaluations found in \href{https://hackmd.io/@alexhkurz/S1D0yP8Bw}{Homework 5}.
\begin{lstlisting}
"x":
Prog (EVar (Id "x"))

"x x":
Prog (EApp (EVar (Id "x")) (EVar (Id "x")))

"x y":
Prog (EApp (EVar (Id "x")) (EVar (Id "y")))

"x y z":
Prog (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z")))

"\ x.x":
Prog (EAbs (Id "x") (EVar (Id "x")))

"\ x.x x":
Prog (EAbs (Id "x") (EApp (EVar (Id "x")) (EVar (Id "x"))))

"(\ x . (\ y . x y)) (\ x.x) z":
Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EVar (Id "x")) (EVar (Id "y"))))) (EAbs (Id "x") (EVar (Id "x")))) (EVar (Id "z")))

"(\ x . \ y . x y z) a b c":
Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EApp (EApp (EVar (Id "x")) (EVar (Id "y"))) (EVar (Id "z"))))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
\end{lstlisting}

\noindent The 2-D abstract syntax trees are found at \href{https://github.com/dapak2002/Pak-D-CPSC-354-Report/blob/main/src/HW5.pdf}{the Github pdf here}.

\noindent The abstract syntax trees for \href{https://hackmd.io/@alexhkurz/H1e4Nv8Bv}{Homework 5 part 2} can be found at the pdf of the evaluations in \href{https://github.com/dapak2002/Pak-D-CPSC-354-Report/blob/main/src/Hw5-pt2.pdf}{the Github file}.

\subsection{Week 6}
This week is focused on evaluating expressions using Lambda Calculus. An example of this can be found in \href{https://youtu.be/for3Meg1Lbc}{Dr. Kurz's tutorial}. 

\subsubsection{Expression Evaluation}
The expression we will be taking a look at this week is:
\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
\end{lstlisting}
Using the method described in the tutorial above, this evalutates to:
\begin{lstlisting}
(\exp . \two . \three . exp two three)
(\m.\n. m n)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
(\two . \three . (\m.\n. m n) two three)
(\f.\x. f (f x))
(\f.\x. f (f (f x)))
=
(\three . (\m.\n. m n) (\f.\x. f (f x)) three)
(\f.\x. f (f (f x)))
= 
((\m.\n. m n) (\f.\x. f (f x)) (\f.\x. f (f (f x))))
=
((\m.\n. m n) (\f2.\x2. f2 (f2 x2)) (\f3.\x3. f3 (f3 (f3 x3))))
=
((\n. (\f2.\x2. f2 (f2 x2)) n) (\f3.\x3. f3 (f3 (f3 x3))))
=
(((\f2.\x2. f2 (f2 x2)) (\f3.\x3. f3 (f3 (f3 x3)))))
=
(((\x2. (\f3.\x3. f3 (f3 (f3 x3))) ((\f3.\x3. f3 (f3 (f3 x3))) x2))))
=
(((\x2. (\x3. ((\f3.\x3. f3 (f3 (f3 x3))) x2) (((\f3.\x3. f3 (f3 (f3 x3))) x2) (((\f3.\x3. f3 (f3 (f3 x3))) x2) x3))))))
=
(((\x2. (\x3. ((\x3. x2 (x2 (x2 x3)))) (((\f3.\x3. f3 (f3 (f3 x3))) x2) (((\f3.\x3. f3 (f3 (f3 x3))) x2) x3))))))
=
(((\x2. (\x3. ((\x3. x2 (x2 (x2 x3)))) (((\x3.  x2 ( x2 ( x2 x3)))) (((\f3.\x3. f3 (f3 (f3 x3))) x2) x3))))))
=
(((\x2. (\x3. ((\x3. x2 (x2 (x2 x3)))) (((\x3.  x2 ( x2 ( x2 x3)))) (((\x3.  x2 ( x2 ( x2 x3)))) x3))))))
=]
(\x2. (\x3. (\x3. x2 (x2 (x2 x3))) ((\x3.  x2 ( x2 ( x2 x3))) (((\x3.  x2 ( x2 ( x2 x3)))) x3))))
=
(\x2. ((\x3. x2 (x2 (x2 ((\x3. x2(x2(x2 x3))) (((\x3.  x2 ( x2 ( x2 x3)))) x3)))))))
=
(\x2. (\x3. x2 (x2 (x2 ((x2 ( x2 ( x2 (((\x3.  x2 ( x2 ( x2 x3)))) x3)))) )))))
=
(\x2. (\x3. x2 (x2 (x2 (x2 ( x2 ( x2 ((x2 ( x2 (x2 x3)))))))))))
=
\x2. (\x3. x2(x2(x2(x2(x2(x2(x2(x2(x2 x3)))))))))
\end{lstlisting}
In the first line, the function is defined as 'exp' with two terms. By analyzing the evaluation we find that the function is essentially the first term to the exponent of the second term.
\section{Project}

For my project I will be looking into various types of programming languages and determining specific use cases and similarities between them. This project is focused on putting characteristics and attributes to programming languages and will be focused on 5-10 different languages. Some specific resources and documentation are Github databases.
\subsection{Specification}
The attributees to look at would be their industry/primary use, popularity, similar languages (as in what other languages do users of one language use), number of repositories, and growth/decline over the years. This will look to create a model in which different languages can be related and characterized.
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\end{document}
